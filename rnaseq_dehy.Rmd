---
title: "rnaseq_dhy"
author: "Dani Blumstein"
date: "2022-10-14"
output: html_document
---


knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE)

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

devtools::install_github('kevinblighe/EnhancedVolcano') 
BiocManager::install("DESeq2", force = TRUE)
BiocManager::install("apeglm")
BiocManager::install("topGO")
BiocManager::install("biomaRt")
BiocManager::install("BiocParallel", force = TRUE)
library("remotes")
remotes::install_github("federicomarini/GeneTonic", 

```{r}
library(biomaRt)
library("GeneTonic")
library("org.Hs.eg.db")
library("AnnotationDbi")
library(DESeq2)
library(dplyr)
library(foreach)
library(data.table)
library(splines)
library(ggthemes)
library(scales)
library(gridExtra)
library(tidyr)
library(pheatmap)
library(RColorBrewer)
library(ggplot2)
library(apeglm)
library(tidyverse)
library(topGO)
library(GO.db)
library(readr)
library(readxl)
library(lubridate)
library(patchwork)
library(EnhancedVolcano)
#library(biomaRt)
```

```{r}
setwd("/Users/danielleblumstein/Documents/UNH/rnaseq/dehy_final")
#call adams fancy functions
source("adams_fancy_functions.R")
dir.create("figures")
dir.create("figures/TalkGeneFigures")
dir.create("figures4publication")
dir.create("results")
dir.create("results/DEresults")
dir.create("results/GOresults")
dir.create("results/WGCNAresults")
ensembl = useMart( "ensembl", dataset = "hsapiens_gene_ensembl" )
```

make sample name spreadsheet
```{r}
### List all samples from expression data 
# get the directory/path for each sample in this study
base_dir <- getwd()

# get directories
filename <- list.files(path = "data/", pattern = "gene.counts", full.names = FALSE, recursive = FALSE)

# append full file path to each sample id
files <- file.path(base_dir, "data/", filename) # files = directory + salmon directory + sample name + quantifictaion file name
names(files) <- "data/"
all(file.exists(files)) # do these all actually exist?

# Make sample spreadsheet 
sample <- as.data.frame(filename)

# get sample
sample$sample <- filename  %>% gsub(pattern = ".gene.counts", replacement = "")
sample$sample <- gsub("_S.*", "", sample$sample)

###############come back to##############
# get tissue
sample$tissue <- unlist(lapply(strsplit(sample$sample, split = "_"),"[[", 3))

# get sex
sample$sex <- unlist(lapply(strsplit(sample$sample, split = "_"),"[[", 2))

# get trt
sample$trt <- unlist(lapply(strsplit(sample$sample, split = "_"),"[[", 4))

# get sample ID
sample$Animal_ID <- unlist(lapply(strsplit(sample$sample, split = "_"),"[[", 1))

#grabbing the phys data and electro/ weight data
cages <- read.csv("data/cages.csv") 
electrolyte_data <- read_excel("data/electrolyte_data.xlsx", na = "NA")
col_order <- c("Animal_ID", "StartTime", "VO2", "VCO2", "H2Og","EE_kJH", "RQ", "time_in_S")
phys_data <- cages[, col_order]
electrolyte_data$Animal_ID <- as.character(electrolyte_data$mouse_ID)

#splitting out only the phys data between 11:00 and 12:00
noon <- period_to_seconds(hms("11:00:00")):period_to_seconds(hms("12:00:00"))
phys_data$TimeOfDay <- ifelse(phys_data$time_in_S %in% noon, "noon", "other")
phys_data <- phys_data[phys_data$TimeOfDay == "noon", ]

mean_VO2<- setNames(aggregate(phys_data$VO2, list(phys_data$Animal_ID), FUN=mean),c("Animal_ID", "mean_VO2"))

mean_VCO2<- setNames(aggregate(phys_data$VCO2, list(phys_data$Animal_ID), FUN=mean),c("Animal_ID", "mean_VCO2"))

mean_EE<- setNames(aggregate(phys_data$EE_kJH, list(phys_data$Animal_ID), FUN=mean),c("Animal_ID", "mean_EE"))

mean_RQ<- setNames(aggregate(phys_data$RQ, list(phys_data$Animal_ID), FUN=mean),c("Animal_ID", "mean_RQ"))

mean_H2Og<- setNames(aggregate(phys_data$H2Og, list(phys_data$Animal_ID), FUN=mean),c("Animal_ID", "mean_H2Og"))

total_H2Og<- setNames(aggregate(cages$H2Og, list(cages$Animal_ID), FUN=sum),c("Animal_ID", "total_H2Og"))
#take the sum of water loss over course of experiment

#merge all data frames together
samples_phys<- Reduce(function(x, y) merge(x, y, all=TRUE), list(mean_VO2, mean_VCO2, mean_RQ, mean_H2Og, total_H2Og, mean_EE,sample))

samples_phys$Animal_ID <- as.character(samples_phys$Animal_ID)
samples <- electrolyte_data %>% right_join(samples_phys)
samples$trt <- as.factor(samples$trt)
samples<- samples[!is.na(samples$filename),]
samples$pro_weight <- abs(samples$total_weight_delta/samples$weight0)

write.csv(samples, "results/samplespreadsheet.csv", row.names = FALSE)
write.csv(cages, "results/cages.csv", row.names = FALSE)
```
s2 <-samples %>% filter(trt == "no") 
s2$pro_weight <- abs(s2$total_weight_delta/s2$weight0)
mod<-lm(s2$pro_weight~s2$Na)
plot(s2$pro_weight~s2$Na)
abline(mod)
summary(mod)

mod<-lm(s2$mean_H2Omg~s2$Na)
plot(s2$mean_H2Omg~s2$Na)
abline(mod)
summary(mod)


```{r}
## Import annotation documents 
#annos <- read_delim("data/annos.txt", delim = "\t", 
#+     escape_double = FALSE, col_names = FALSE, 
#+     locale = locale(), trim_ws = TRUE)
annos <- read_csv("/Users/danielleblumstein/Documents/UNH/rnaseq/dehy_final/data/annos.txt")

library("org.Hs.eg.db")
annos$ensid = mapIds(org.Hs.eg.db,
                    keys=annos$gene, 
                    column="ENSEMBL",
                    keytype="SYMBOL",
                    multiVals="first")
```


```{r}
countdata <- data.frame(annos$transcript)
colnames(countdata) <- "transcript"
for (counts in (1:length(samples$filename)))
  {
  # import data for that sample
  toimport <- samples$filename[counts]
  tmpdata <- read.table(paste0("data/", toimport), header = FALSE, sep = "\t")
  # sample id
  samplename <- toimport  %>% gsub(pattern = ".gene.counts", replacement = "")
  samplename <- gsub("_S.*", "", samplename)
  colnames(tmpdata) <- c("transcript", samplename)
  countdata <- dplyr::left_join(countdata, tmpdata, by = "transcript")
}
dim(countdata)
countdata <- data.frame(countdata, row.names = 1)
names(countdata)=str_sub(names(countdata),2)
countdata

write.csv(countdata, "countdata.csv", row.names = FALSE)
```


Quick data control. Change any "NA" values to "0"
```{r data QC}
# change all NA to 0
print(paste0("Number of NA after import:", sum(is.na(countdata))))
countdata[is.na(countdata)] <-  0
print(paste0("Number of NA after NA removal:", sum(is.na(countdata))))
print(paste0("Number of genes after import:", nrow(countdata)))

## remove all unknown proteins
countdata <- countdata[!rownames(countdata) == "proteins of unknown function", ]
print(paste("Number of genes after removing all 'proteins of unknown function':", nrow(countdata)))

dim(countdata)
countdata
```


The count data table is currently a dataframe of counts, with each row representing a transcript in the genome. Some genes are represented by multiple transcripts in the genome, and hence our count data table. Here I will manipulate the data so that we can do a gene level analysis.

```{R Create a data frame of gene level count data}
# make rownames column 1
countdata <- setDT(countdata, keep.rownames = "transcript")[]

# add gene symbol
countdata2 <- dplyr::left_join(annos, countdata, by = "transcript")
dim(countdata2)

# change all NA to 0
print(paste("Number of NA after import:", sum(is.na(countdata2))))

countdata2 <- countdata2 %>% 
    mutate_at(5:163, ~replace_na(.,0))

# combine all counts that map to the same gene
countdata3 <- aggregate(countdata2[, 5:163], list(countdata2$gene), sum)
dim(countdata3)

countdata3[is.na(countdata3)] <-  0
colnames(countdata3)[1] <- "Gene"
countdata <- countdata3

# make gene name column
countdata <- data.frame(countdata, row.names = 1)
print(paste("Number of genes after combining all counts that map to the same gene:", nrow(countdata)))

for ( col in 1:ncol(countdata)){
    colnames(countdata)[col] <-  sub("X*", "", colnames(countdata)[col])
}

# save gene-level count data
write.table(countdata, "data/gene.level.count.data.tsv", row.names = TRUE, sep = "\t")
```

### DESeq data creation 

```{r DESEQ creation}

all(rownames(samples) %in% colnames(countdata))
all(rownames(samples) == colnames(countdata))

# crea DESeq dataset
dds <- DESeqDataSetFromMatrix(countData = countdata,
                                       colData = samples,
                                       design = ~ sex + tissue +trt)

```


### Crea a PCA

```{R PCA}
vsd <- varianceStabilizingTransformation(dds, blind = FALSE)
# get PC1 and PC2 data
pcaData <- plotPCA(vsd, intgroup = c("sex", "tissue", "trt"), returnData = TRUE)
# get percent variation
percentVar <- round(100 * attr(pcaData, "percentVar"))
# pca code
pca <- ggplot(pcaData, aes(x = PC1, y = PC2, color = tissue, shape = trt, name=name)) +
  stat_ellipse(aes(group = tissue, linetype = tissue), type = "t", level = 0.95, size = 1.25, show.legend = FALSE) +
  #scale_linetype_manual(values=c("twodash", "longdash", "solid"), guide = FALSE) +
  geom_point(size = 3, show.legend = TRUE) + 
  #scale_color_manual(values = c("orange1", "red1", "yellow2", "chartreuse4")) +
  #scale_shape_manual(values = c(8,9,15,16,10,17,18,11,13)) + 
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  coord_fixed() + theme_bw() +
  guides(shape = guide_legend(order = 1),color = guide_legend(order = 2)) 
# save
ggsave("figures/PCA.png", width = 8, height = 4.6, dpi = 600)


library(plotly)
ggplotly(pca)
```


### Make the final PCA for the publication

```{R PCA for publication}
# pca code
ggplot(pcaData, aes(x = PC1, y = PC2, color = tissue, shape = trt)) +
  stat_ellipse(aes(group = tissue, linetype = tissue), type = "t", level = 0.95, size = 1.25, show.legend = FALSE) +
  #scale_linetype_manual(values=c("twodash", "longdash", "solid"), guide = FALSE) +
  geom_point(size = 3, show.legend = TRUE) + 
  #scale_color_manual(values = c("orange1", "red1", "yellow2", "chartreuse4")) +
  #scale_shape_manual(values = c(8,9,15,16,10,17,18,11,13)) + 
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  coord_fixed() + theme_bw() +
  guides(shape = guide_legend(order = 1),color = guide_legend(order = 2)) 
  
ggsave("figures4publication/PCA.png", width = 8, height = 4.6, dpi = 600)
```


### Crea a heatmap

```{r HEATWAVE, eval = FALSE}
# crea sample distances and sample distance matrix
sampleDists <- dist(t(assay(vsd)))
sampleDistMatrix <- as.matrix( sampleDists )

# plot heatmap
heatmapcolors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix, clusr_rows = FALSE, clusr_cols = FALSE, col = heatmapcolors)
# plot and save heatmap
png("figures/heatmap.png", width = 14.63, height = 10, units = "in", res = 600)
pheatmap(sampleDistMatrix, clusr_rows = FALSE, clusr_cols = FALSE, col = heatmapcolors)
dev.off()
```

### Differential expression analyses

I will run some differential expression analyses now. I want to account for sex, trt, and tissue in my analyses.


Run differential expression analysis. What is the effect of sex?
```{r LRT sex, eval = FALSE}
ddssex <- DESeqDataSetFromMatrix(countData = countdata,
                                       colData = samples,
                                       design = ~ trt + tissue + sex)

ddssex <- estimateSizeFactors(ddssex)
idx <- rowSums(counts(ddssex, normalized=TRUE) >= 10 ) >= 8

ddssex <- ddssex[idx,]
print(paste("Number of genes after filtering by total expression:", nrow(ddssex)))

# run LRT test
ddssex <- DESeq(ddssex, test="LRT", reduced = ~ trt + tissue)
ressex <- results(ddssex)
ressex$transcript <- mcols(ressex)$transcript
# how many are "significant"?
table(ressex[,"padj"] < 0.05)
res05 <- results(ddssex, alpha=0.05)
summary(res05)
```

```{r LRT tissue, eval = FALSE}
ddstissue <- DESeqDataSetFromMatrix(countData = countdata,
                                       colData = samples,
                                       design = ~ trt + sex + tissue)

ddstissue <- estimateSizeFactors(ddstissue)
idx <- rowSums(counts(ddstissue, normalized=TRUE) >= 10 ) >= 8

ddstissue <- ddstissue[idx,]
print(paste("Number of genes after filtering by total expression:", nrow(ddstissue)))

# run LRT test
ddstissue <- DESeq(ddstissue, test="LRT", reduced = ~ trt + sex)
restissue <- results(ddstissue)
restissue$symbol <- mcols(restissue)$symbol
# how many are "significant"?
table(restissue[,"padj"] < 0.05)
summary(restissue)
```

```{r}
ddstrt <- DESeqDataSetFromMatrix(countData = countdata,
                                       colData = samples,
                                       design = ~ sex + tissue + trt)

ddstrt <- estimateSizeFactors(ddstrt)
idx <- rowSums(counts(ddstrt, normalized=TRUE) >= 10 ) >= 8

ddstrt <- ddstrt[idx,]
print(paste("Number of genes after filtering by total expression:", nrow(ddstrt)))


ddstrt <- DESeq(ddstrt,test="Wald")
annos$ensembl <- as.character(annos$ensid)

#rename transcript rows to ensid names
rownames(ddstrt)=annos$ensid[match(names(ddstrt),annos$gene)]
#remove the NAs (those transcripts dont have a ensid name)
ddstrt <- ddstrt[complete.cases(rownames(ddstrt)), ]
ddstrt <- ddstrt[!rownames(ddstrt) == "NULL", ] 

ddstrt <- estimateSizeFactors(ddstrt)
normalized_counts <- vst(ddstrt, blind = FALSE)
all_Expr <- assay(normalized_counts)
```

## now you have normalized read counts - yay!

```{r}
for ( col in 1:ncol(kid_Expr)){
    colnames(kid_Expr)[col] <-  sub("X", "", colnames(kid_Expr)[col])
}

for ( col in 1:ncol(liv_Expr)){
    colnames(liv_Expr)[col] <-  sub("X", "", colnames(liv_Expr)[col])
}

for ( col in 1:ncol(lu_Expr)){
    colnames(lu_Expr)[col] <-  sub("X", "", colnames(lu_Expr)[col])
}

for ( col in 1:ncol(gi_Expr)){
    colnames(gi_Expr)[col] <-  sub("X", "", colnames(gi_Expr)[col])
}

for ( col in 1:ncol(hyp_Expr)){
    colnames(hyp_Expr)[col] <-  sub("X", "", colnames(hyp_Expr)[col])
}

lst <- list(kid_Expr,liv_Expr,lu_Expr,gi_Expr,hyp_Expr)
genes_to_keep <- Reduce(intersect, lapply(lst, rownames))

filteredkid <- kid_Expr[rownames(kid_Expr) %in% genes_to_keep,]
filteredliv <- liv_Expr[rownames(liv_Expr) %in% genes_to_keep,]
filteredlu <- lu_Expr[rownames(lu_Expr) %in% genes_to_keep,]
filteredgi <- gi_Expr[rownames(gi_Expr) %in% genes_to_keep,]
filteredhyp <- hyp_Expr[rownames(hyp_Expr) %in% genes_to_keep,]


nSets <- 5
setLabels = c("kid", "liv","lu","gi","hyp")
multiExpr = vector(mode = "list", length = nSets)

# load the expression variables in multiExpr
multiExpr[[1]] = list(data = as.data.frame(t(filteredkid)))
multiExpr[[2]] = list(data = as.data.frame(t(filteredliv)))
multiExpr[[3]] = list(data = as.data.frame(t(filteredlu)))
multiExpr[[4]] = list(data = as.data.frame(t(filteredgi)))
multiExpr[[5]] = list(data = as.data.frame(t(filteredhyp)))
# For easier labeling of plots, create a vector holding descriptive names of the two sets.

names(multiExpr) = setLabels
lapply(multiExpr, lapply, dim)

exprSize = checkSets(multiExpr)
```

```{r}
sampleTrees = list()
for (set in 1:nSets)
{
sampleTrees[[set]] = hclust(dist(multiExpr[[set]]$data), method = "average")
}


par(mfrow=c(5,1))
par(mar = c(0, 4, 2, 0))
for (set in 1:nSets)
{
plot(sampleTrees[[set]], main = paste("Sample clustering on all genes in", setLabels[set]),xlab="", sub="", cex = 0.7)
}
```


```{r}
# Form a multi-set structure that will hold the clinical traits.
Traits = vector(mode="list", length = nSets)
for (set in 1:nSets)
{
setSamples = rownames(multiExpr[[set]]$data)
traitRows = match(setSamples, samples$sample)
Traits[[set]] = list(data = samples[traitRows, -1])
#rownames(Traits[[set]]$data) = samples[traitRows, 38]
}
collectGarbage()

# Define data set dimensions
nGenes = exprSize$nGenes;
nSamples = exprSize$nSamples;

save(multiExpr, Traits, nGenes, nSamples, setLabels, exprSize,file = "Consensus-dataInput.RData")
```

```{r}
lnames = load(file = "Consensus-dataInput.RData");

# The variable lnames contains the names of loaded variables.
lnames
# Get the number of sets in the multiExpr structure.
nSets = checkSets(multiExpr)$nSets
```

```{r}
# Choose a set of soft-thresholding powers
powers = c(seq(4,10,by=1), seq(12,20, by=2));
# Initialize a list to hold the results of scale-free analysis
powerTables = vector(mode = "list", length = nSets);
# Call the network topology analysis function for each set in turn
for (set in 1:nSets)
powerTables[[set]] = list(data = pickSoftThreshold(multiExpr[[set]]$data, powerVector=powers,verbose = 2)[[2]]);
collectGarbage();
# Plot the results:
colors = c("black", "red")
# Will plot these columns of the returned scale free analysis tables
plotCols = c(2,5,6,7)
colNames = c("Scale Free Topology Model Fit", "Mean connectivity", "Median connectivity",
"Max connectivity");
# Get the minima and maxima of the plotted points
ylim = matrix(NA, nrow = 2, ncol = 4);

for (set in 1:nSets)
{
for (col in 1:length(plotCols))

{
ylim[1, col] = min(ylim[1, col], powerTables[[set]]$data[, plotCols[col]], na.rm = TRUE);
ylim[2, col] = max(ylim[2, col], powerTables[[set]]$data[, plotCols[col]], na.rm = TRUE);
}
}

# Plot the quantities in the chosen columns vs. the soft thresholding power
sizeGrWindow(8, 6)
#pdf(file = "Plots/scaleFreeAnalysis.pdf", wi = 8, he = 6)
par(mfcol = c(2,2));
par(mar = c(4.2, 4.2 , 2.2, 0.5))
cex1 = 0.7;
for (col in 1:length(plotCols)) for (set in 1:nSets)
{
if (set==1)
{
plot(powerTables[[set]]$data[,1], -sign(powerTables[[set]]$data[,3])*powerTables[[set]]$data[,2],
xlab="Soft Threshold (power)",ylab=colNames[col],type="n", ylim = ylim[, col],
main = colNames[col]);
addGrid();
}
if (col==1)
{
text(powerTables[[set]]$data[,1], -sign(powerTables[[set]]$data[,3])*powerTables[[set]]$data[,2],
labels=powers,cex=cex1,col=colors[set]);
} else
text(powerTables[[set]]$data[,1], powerTables[[set]]$data[,plotCols[col]],
labels=powers,cex=cex1,col=colors[set]);
if (col==1)
{
legend("bottomright", legend = setLabels, col = colors, pch = 20) ;
} else
legend("topright", legend = setLabels, col = colors, pch = 20) ;
}
dev.off();
```

```{r}
net = blockwiseConsensusModules(multiExpr, power = 10, minModuleSize = 30, deepSplit = 2,pamRespectsDendro = FALSE,mergeCutHeight = 0.25, numericLabels = TRUE,minKMEtoStay = 0,saveTOMs = TRUE, verbose = 5, maxBlockSize=14000,)
```

```{r}
consMEs = net$multiMEs;
moduleLabels = net$colors;
# Convert the numeric labels to color labels
moduleColors = labels2colors(moduleLabels)
consTree = net$dendrograms[[1]];

sizeGrWindow(8,6);
#pdf(file = "Plots/ConsensusDendrogram-auto.pdf", wi = 8, he = 6)
plotDendroAndColors(consTree, moduleColors,"Module colors",dendroLabels = FALSE, hang = 0.03,addGuide = TRUE, guideHang = 0.05,main = "Consensus gene dendrogram and module colors")
dev.off()
```





```{r}
##################  WGCNA  ##########################

#code to subset just DE genes
#all_master <- read.csv("results/DE_all/trt_genes.csv", header = TRUE)
#allref <- all_master$Gene
#all_Expr <- subset(normalized_counts, subset = rownames(normalized_counts) %in% allref)

#Remove gene information and transpose the expression data
rownames(all_Expr)<-NULL
all_Expr <- t(all_Expr)

##########check included genes#########
gsg = goodSamplesGenes(all_Expr, verbose = 3);
gsg$allOK
```

```{r}
# Trait data generation ---------------------------------------------------
# Now we read in the phenotypic trait data
samples <- as.data.frame(samples)
dim(samples)
traitData_all <- 'row.names<-'(samples, samples$sample)
traitData_all$trt <- as.numeric(as.factor(traitData_all$trt))
traitData_all$sex <- as.numeric(as.factor(traitData_all$sex))
traitData_all$tissue <- as.numeric(as.factor(traitData_all$tissue))

# Choose columns of trait dataset to be used in downstream analyses
colnames(traitData_all)
traitData_all <- traitData_all %>% select(c('sex','total_weight_delta',"pro_weight","Na","BUN","AnGap","K","Crea","Hct","Cl","Glu","Hb*","TCO2","iCa","trt","mean_RQ","mean_EE","mean_H2Og","body_temp_3","tissue"))
#traitData_all <- 'row.names<-'(traitData_all, traitData_all$sample)
traitData_all <- as.data.frame(lapply(traitData_all, as.numeric))
```

```{r}
#### filter samples ########
A_all=adjacency(t(all_Expr),type="distance")
# this calculates the whole network connectivity
k_all=as.numeric(apply(A_all,2,sum))-1
# standardized connectivity
Z.k_all=scale(k_all)

# Designate samples as outlying
# if their Z.k value is below the threshold
thresholdZ.k=-4 # often -2.5

# the color vector indicates outlyingness (red)
outlierColor_all <- ifelse(Z.k_all<thresholdZ.k,"red","black")

# calculate the cluster tree using flashClust or hclust
sampleTree_all <- flashClust(as.dist(1-A_all), method = "average")
# Convert traits to a color representation:
# where red indicates high values


traitColors = data.frame(numbers2colors(traitData_all,signed=FALSE))
dimnames(traitColors)[[2]] = paste(names(traitData_all))
datColors = data.frame(outlier = outlierColor_all,traitColors)
plotDendroAndColors(sampleTree_all,groupLabels=names(datColors),
                    colors=datColors,main="Sample Dendrogram and Trait Heatmap")

```


```{r}
############ Choosing the soft threshold beta via scale free topology
# Choose a set of soft thresholding powers
powers=c(1:30) # in practice this should include powers up to 20.
# choose power based on sft_JZ criterion
sft_all=pickSoftThreshold(all_Expr,powerVector=powers, networkType = "signed")
# Plot the results:

par(mfrow=c(1,2))
# sft_all index as a function of different powers
plot(sft_all$fitIndices[,1],-sign(sft_all$fitIndices[,3])*sft_all$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="sft_all, unsigned R^2",type="n",main=paste("Scale independence"))
text(sft_all$fitIndices[,1],-sign(sft_all$fitIndices[,3])*sft_all$fitIndices[,2],
     labels=powers,col="red", pch=1, cex=.50)
# this line corresponds to using an R^2 cut-off of h
abline(h=0.85,col="red")
# Mean connectivity as a function of different powers
plot(sft_all$fitIndices[,1],sft_all$fitIndices[,5],type="n",
     xlab="Soft Threshold (power)",ylab="Mean Connectivity",main=paste("Mean connectivity"))
text(sft_all$fitIndices[,1],sft_all$fitIndices[,5],labels=powers,col="red", cex=.50)
```

```{r}
softPower = 14 #Chosen in the graphs before
##########Automatic module detection via dynamic cutting

merallngThresh = 0.25
net_all = blockwiseModules(all_Expr,corType="pearson",
                          maxBlockSize=14000,networkType="signed hybrid",power=softPower,minModuleSize=20,
                          mergeCutHeight=merallngThresh,numericLabels=F,saveTOMs=TRUE,
                          pamRespectsDendro=FALSE,saveTOMFileBase="all_TEST")

moduleLabelsAutomatic_all=net_all$colors

# Convert labels to colors for plotting
moduleColorsAutomatic_all = labels2colors(moduleLabelsAutomatic_all)

# A data frame with module eigengenes can be obtained as follows
MEsAutomatic_all=net_all$MEs
```


```{r}
#this is proportional weight loss
weight_g_all = as.data.frame(traitData_all$pro_weight)
names(weight_g_all)="weight_g_all"

GS.all=as.numeric(cor(all_Expr,traitData_all,use="p"))
# This translates the numeric values into colors
GS.allWColor_all=numbers2colors(GS.all,signed=T)

blocknumber=1
datColors_all=data.frame(moduleColorsAutomatic_all,GS.allWColor_all)[net_all$blockGenes[[blocknumber]],]

# Plot the dendrogram and the module colors underneath
plotDendroAndColors(net_all$dendrograms[[blocknumber]],colors=datColors_all,
                    groupLabels=c("Module colors"),dendroLabels=FALSE,
                    hang=0.03,addGuide=TRUE,guideHang=0.05)

# Choose a module assignment
moduleColors_all=moduleColorsAutomatic_all

# Define numbers of genes and samples
nGenesall = ncol(all_Expr)
nSamplesall = nrow(all_Expr)

# Recalculate MEs with color labels
MEs0all = moduleEigengenes(all_Expr,moduleColors_all)$eigengenes

MEs_all = orderMEs(MEs0all)
modTraitCor_all = cor(MEs_all, traitData_all, use = "p")
modTraitP_all = corPvalueStudent(modTraitCor_all, nSamplesall)

#Since we have a moderately large number of modules and traits,
#a suitable graphical representation will help in reading
#the table. We color code each association by the correlation value:
# Will display correlations and their p-values
textMatrix_all = paste(signif(modTraitCor_all, 2), "\n(",
                      signif(modTraitP_all, 1), ")", sep = "")
dim(textMatrix_all) = dim(modTraitCor_all)
par(mar = c(6, 8.5, 3, 3))

# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = modTraitCor_all, xLabels = names(traitData_all),
               yLabels = names(MEs_all), ySymbols = names(MEs_all), 
               colorLabels =FALSE,colors=blueWhiteRed(50),textMatrix=textMatrix_all,
               setStdMarallns = FALSE, cex.text = 0.4, zlim = c(-1,1),
               main = paste("Module-trait relationships, all"))
png("figures/WGCNA_heatmap.png", width = 9.5, height = 12, units = "in", res = 300)

ME.dissimilarity = 1-cor(MEs0all, use="complete") #Calculate eigengene dissimilarity
METree = hclust(as.dist(ME.dissimilarity), method = "average") #Clustering eigengenes 
par(mar = c(0,4,2,0)) #seting margin sizes
par(cex = 0.6);#scaling the graphic
plot(METree)
abline(h=.25, col = "red") #a height of .25 corresponds to correlation of .75

```

```{r}
############################write tables w/ corr info###################################################################
modNames_all = substring(names(MEs_all), 3)
geneModuleMembership_all = as.data.frame(cor(all_Expr, MEs_all, use = "p"));
MMPvalue_all = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership_all), nSamplesall));
names(geneModuleMembership_all) = paste("MM", modNames_all, sep="");
names(MMPvalue_all) = paste("p.MM", modNames_all, sep="");
geneTraitSignificance_all = as.data.frame(cor(all_Expr, weight_g_all, use = "p"));
GSPvalue_all = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance_all), nSamplesall));
names(geneTraitSignificance_all) = paste("GS.", names(weight_g_all), sep="");
names(GSPvalue_all) = paste("p.GS.", names(weight_g_all), sep="");

All_module_correlations_all <- subset(signif(modTraitP_all, 1))
W_module_correlations_all <- All_module_correlations_all[,1]
W_module_adjusted_correlations_all <- p.adjust(W_module_correlations_all, method = "fdr")

# (aka. module eigengene based connectivity kME):
datKME_all=signedKME(all_Expr, MEs_all)

Module_eigengenes_all <- net_all$MEs_all
rownames(MEs_all) <- rownames(all_Expr)
write.csv(MEs_all, file="results/WGCNAresults/ALLSAMPLES_MEs_signed.csv")
write.csv(modTraitP_all, file="results/WGCNAresults/ALLSAMPLES_MEs_P_Pearson.csv")
```


```{r}
##################################write MM and GS values to file for each gene
# Create the starting data frame

genes_all <- assay(normalized_counts)
geneInfo0_all = data.frame(Gene = genes_all,
                          moduleColor = moduleColors_all,
                          geneTraitSignificance_all,
                          GSPvalue_all)
# Order modules by their significance for weight
MEs_all2 <- MEs_all[,-1]
modOrder = order(-abs(cor(MEs_all2, weight_g_all, use = "p")));
# Add module membership information in the chosen order
for (mod in 1:ncol(geneModuleMembership_all))
{
  oldNames = names(geneInfo0_all)
  geneInfo0_all = data.frame(geneInfo0_all, geneModuleMembership_all[, modOrder[mod]],
                            MMPvalue_all[, modOrder[mod]]);
  names(geneInfo0_all) = c(oldNames, paste("MM.", modNames_all[modOrder[mod]], sep=""),
                          paste("p.MM.", modNames_all[modOrder[mod]], sep=""))
}

geneInfo0_all$ensembl <- rownames(geneInfo0_all)
geneInfo0_all <- merge(geneInfo0_all, annos, by.x = "ensembl", by.y = "ensembl")
geneInfo0_all$ensid <- NULL
```

```{r}
for ( col in 1:ncol(ME.dissimilarity)){
    colnames(ME.dissimilarity)[col] <-  sub("ME", "", colnames(ME.dissimilarity)[col])
}

for ( row in 1:nrow(ME.dissimilarity)){
    rownames(ME.dissimilarity)[row] <-  sub("ME", "", rownames(ME.dissimilarity)[row])
}

nodes <- as.data.frame(table(moduleColorsAutomatic_all))
links <- melt(ME.dissimilarity)
data_zero <- filter_if(links, is.numeric, all_vars((.) != 0))

dim(ME.dissimilarity)
net <- graph_from_adjacency_matrix(ME.dissimilarity,weighted = TRUE,)
net <- simplify(net, remove.multiple = F, remove.loops = T)
V(net)$color <- rownames(ME.dissimilarity)
V(net)$size <- log(nodes$Freq)*5
E(net)$width <- log(data_zero$value)*10
#change arrow size and edge color:
E(net)$edge.color <- "gray80"
E(net)$edge.arrow.mode <- 0

layouts <- grep("^layout_", ls("package:igraph"), value=TRUE)[-1]
# Remove layouts that do not apply to our graph.
layouts <- layouts[!grepl("bipartite|merge|norm|sugiyama|tree", layouts)]
par(mfrow=c(3,3), mar=c(1,1,1,1))
for (layout in layouts) {
print(layout)
l <- do.call(layout, list(net))
plot(net, edge.arrow.mode=0, layout=l, main=layout) }
# Choose final layout
par(mfrow=c(1,1))
plot(net, edge.arrow.mode=0, layout=layout_with_kk)

#barplot(nodes$Freq, col = rownames(ME.dissimilarity), ylim = c(0,5000))
```

Now I will run these test for each tissue independently. 
in a new script, one per tissue cause life

after running the individual tissue scripts take advantage of the fact that it is in Rs global enviroment and come back to this stuff
```{r}
compa_list <- list(
  gi = res_enrich_gi,
  lu = res_enrich_lu,
  liv = res_enrich_liv
)

gs_horizon(res_enrich_all,
           compared_res_enrich_list = compa_list,
           n_gs = 30,
           sort_by = "clustered")


lu <- PCA_graph(lu_dds_trt, "lu")
liv <- PCA_graph(liv_dds_trt, "liv")
hyp <- PCA_graph(hyp_dds_trt, "hyp")
gi <- PCA_graph(gi_dds_trt, "gi")
all <- PCA_graph(all_dds_trt, "all")

lu+liv+hyp+gi+ all
```

upsetR
number of GO terms overlapping each tissue
```{r}
#res_enrich_hyp1 <- dplyr::select(res_enrich_hyp, gs_id, DE_count)
#res_enrich_hyp1$hyp <- as.integer(res_enrich_hyp1$DE_count)
#res_enrich_hyp1$DE_count <- NULL

res_enrich_all1 <- dplyr::select(res_enrich_all, gs_id, DE_count)
res_enrich_all1$all <- as.integer(res_enrich_all1$DE_count)
res_enrich_all1$DE_count <- NULL

res_enrich_liv1 <- dplyr::select(res_enrich_liv, gs_id, DE_count)
res_enrich_liv1$liv <- as.integer(res_enrich_liv1$DE_count)
res_enrich_liv1$DE_count <- NULL

res_enrich_lu1 <- dplyr::select(res_enrich_lu, gs_id, DE_count)
res_enrich_lu1$lu <- as.integer(res_enrich_lu1$DE_count)
res_enrich_lu1$DE_count <- NULL

res_enrich_gi1 <- dplyr::select(res_enrich_gi, gs_id, DE_count)
res_enrich_gi1$gi <- as.integer(res_enrich_gi1$DE_count)
res_enrich_gi1$DE_count <- NULL

df_list <- list(res_enrich_all1, res_enrich_liv1, res_enrich_lu1, res_enrich_gi1)

# merge all data frames and move the common column to first position and keep all other columns
newdf <- df_list %>% purrr::reduce(full_join, by='gs_id') %>% 
dplyr::select(gs_id, everything())

newdf[is.na(newdf)] = 0
newdf[newdf > 0] <- 1

library(UpSetR)
upset(newdf, sets = c("all", "liv", "lu", "gi"), mb.ratio = c(0.55, 0.45), order.by = "freq")

countdata1<-countdata

multi_fun <- function(x){
  cat <- paste(x[3:4], collapse = "_")
  
}
test <- strsplit(colnames(countdata1), split = "_")
colnames(countdata1)<-sapply(test,multi_fun)

countdata1[is.na(countdata1)] = 0
countdata1[countdata1 > 0] <- 1

unique(colnames(countdata1))
upset(countdata1, sets = c("gi_yes","hyp_yes","all_yes",
                           "liv_yes","lu_yes","gi_no",
                           "hyp_no","liv_no","lu_no","all_no" ), 
                          mb.ratio = c(0.55, 0.45), order.by = "freq")



#"F_gi_yes","F_hyp_yes","F_all_yes",
#"F_liv_yes","F_lu_yes" ,"F_gi_no",
#"F_hyp_no","F_liv_no","F_lu_no",
#"F_all_no","M_liv_yes","M_all_yes",
#"M_lu_yes","M_gi_yes","M_hyp_yes",
#"M_hyp_no","M_all_no","M_liv_no","M_gi_no","M_lu_no"
```


upsetR
number of genes overlapping each tissue
```{r}
restrt_all<- as.data.frame(restrt_all)
restrt_all$gene <- rownames(restrt_all)

restrt_liv<- as.data.frame(restrt_liv)
restrt_liv$gene <- rownames(restrt_liv)

restrt_lu<- as.data.frame(restrt_lu)
restrt_lu$gene <- rownames(restrt_lu)

restrt_gi<- as.data.frame(restrt_gi)
restrt_gi$gene <- rownames(restrt_gi)

res_enrich_all1 <- dplyr::select(restrt_all, gene, pvalue)
res_enrich_all1$all <- as.integer(res_enrich_all1$pvalue) + 1
res_enrich_all1$pvalue <- NULL

res_enrich_liv1 <- dplyr::select(restrt_liv, gene, pvalue)
res_enrich_liv1$liv <- as.integer(res_enrich_liv1$pvalue)+ 1
res_enrich_liv1$pvalue <- NULL

res_enrich_lu1 <- dplyr::select(restrt_lu, gene, pvalue)
res_enrich_lu1$lu <- as.integer(res_enrich_lu1$pvalue)+ 1
res_enrich_lu1$pvalue <- NULL

res_enrich_gi1 <- dplyr::select(restrt_gi, gene, pvalue)
res_enrich_gi1$gi <- as.integer(res_enrich_gi1$pvalue)+ 1
res_enrich_gi1$pvalue <- NULL

df_list <- list(res_enrich_all1, res_enrich_liv1, res_enrich_lu1, res_enrich_gi1)

# merge all data frames and move the common column to first position and keep all other columns
newdf <- df_list %>% purrr::reduce(full_join, by='gene') %>% 
dplyr::select(gene, everything())

newdf[is.na(newdf)] = 0
newdf[newdf > 0] <- 1

library(UpSetR)
upset(newdf, sets = c("all", "liv", "lu", "gi"), mb.ratio = c(0.55, 0.45), order.by = "freq")
```