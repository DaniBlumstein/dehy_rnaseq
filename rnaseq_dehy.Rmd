---
title: "rnaseq_dhy"
author: "Dani Blumstein"
date: "2022-10-14"
output: html_document
---


knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE)

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

devtools::install_github('kevinblighe/EnhancedVolcano') 
BiocManager::install("DESeq2", force = TRUE)
BiocManager::install("apeglm")
BiocManager::install("topGO")
BiocManager::install("biomaRt")
BiocManager::install("BiocParallel", force = TRUE)
library("remotes")
remotes::install_github("federicomarini/GeneTonic", 

```{r}
library(biomaRt)
library("GeneTonic")
library("org.Hs.eg.db")
library("AnnotationDbi")
library(DESeq2)
library(dplyr)
library(foreach)
library(data.table)
library(splines)
library(ggthemes)
library(scales)
library(gridExtra)
library(tidyr)
library(pheatmap)
library(RColorBrewer)
library(ggplot2)
library(apeglm)
library(tidyverse)
library(topGO)
library(GO.db)
library(readr)
library(readxl)
library(lubridate)
library(patchwork)
library(EnhancedVolcano)
#library(biomaRt)

```

```{r}
setwd("/Users/danielleblumstein/Documents/UNH/rnaseq/dehy_final")
#call adams fancy functions
source("adams_fancy_functions.R")
dir.create("figures")
dir.create("figures/TalkGeneFigures")
dir.create("figures4publication")
dir.create("results")
dir.create("results/DEresults")
dir.create("results/GOresults")
dir.create("results/WGCNAresults")
ensembl = useMart( "ensembl", dataset = "hsapiens_gene_ensembl" )
```

make sample name spreadsheet
```{r}
### List all samples from expression data 
# get the directory/path for each sample in this study
base_dir <- getwd()

# get directories
filename <- list.files(path = "data/", pattern = "gene.counts", full.names = FALSE, recursive = FALSE)

# append full file path to each sample id
files <- file.path(base_dir, "data/", filename) # files = directory + salmon directory + sample name + quantifictaion file name
names(files) <- "data/"
all(file.exists(files)) # do these all actually exist?

# Make sample spreadsheet 
sample <- as.data.frame(filename)

# get sample
sample$sample <- filename  %>% gsub(pattern = ".gene.counts", replacement = "")
sample$sample <- gsub("_S.*", "", sample$sample)

###############come back to##############
# get tissue
sample$tissue <- unlist(lapply(strsplit(sample$sample, split = "_"),"[[", 3))

# get sex
sample$sex <- unlist(lapply(strsplit(sample$sample, split = "_"),"[[", 2))

# get trt
sample$trt <- unlist(lapply(strsplit(sample$sample, split = "_"),"[[", 4))

# get sample ID
sample$Animal_ID <- unlist(lapply(strsplit(sample$sample, split = "_"),"[[", 1))

#grabbing the phys data and electro/ weight data
cages <- read.csv("data/cages.csv") 
electrolyte_data <- read_excel("data/electrolyte_data.xlsx", na = "NA")
col_order <- c("Animal_ID", "StartTime", "VO2", "VCO2", "H2Og","EE_kJH", "RQ", "time_in_S")
phys_data <- cages[, col_order]
electrolyte_data$Animal_ID <- as.character(electrolyte_data$mouse_ID)

#splitting out only the phys data between 11:00 and 12:00
noon <- period_to_seconds(hms("11:00:00")):period_to_seconds(hms("12:00:00"))
phys_data$TimeOfDay <- ifelse(phys_data$time_in_S %in% noon, "noon", "other")
phys_data <- phys_data[phys_data$TimeOfDay == "noon", ]

mean_VO2<- setNames(aggregate(phys_data$VO2, list(phys_data$Animal_ID), FUN=mean),c("Animal_ID", "mean_VO2"))

mean_VCO2<- setNames(aggregate(phys_data$VCO2, list(phys_data$Animal_ID), FUN=mean),c("Animal_ID", "mean_VCO2"))

mean_EE<- setNames(aggregate(phys_data$EE_kJH, list(phys_data$Animal_ID), FUN=mean),c("Animal_ID", "mean_EE"))

mean_RQ<- setNames(aggregate(phys_data$RQ, list(phys_data$Animal_ID), FUN=mean),c("Animal_ID", "mean_RQ"))

mean_H2Og<- setNames(aggregate(phys_data$H2Og, list(phys_data$Animal_ID), FUN=mean),c("Animal_ID", "mean_H2Og"))

total_H2Og<- setNames(aggregate(cages$H2Og, list(cages$Animal_ID), FUN=sum),c("Animal_ID", "total_H2Og"))
#take the sum of water loss over course of experiment

#merge all data frames together
samples_phys<- Reduce(function(x, y) merge(x, y, all=TRUE), list(mean_VO2, mean_VCO2, mean_RQ, mean_H2Og, total_H2Og, mean_EE,sample))

samples_phys$Animal_ID <- as.character(samples_phys$Animal_ID)
samples <- electrolyte_data %>% dplyr::right_join(samples_phys)
samples$trt <- as.factor(samples$trt)
samples<- samples[!is.na(samples$filename),]
samples$pro_weight <- abs(samples$total_weight_delta/samples$weight0)

write.csv(samples, "results/samplespreadsheet.csv", row.names = FALSE)
write.csv(cages, "results/cages.csv", row.names = FALSE)
```
s2 <-samples %>% filter(trt == "no") 
s2$pro_weight <- abs(s2$total_weight_delta/s2$weight0)
mod<-lm(s2$pro_weight~s2$Na)
plot(s2$pro_weight~s2$Na)
abline(mod)
summary(mod)

mod<-lm(s2$mean_H2Omg~s2$Na)
plot(s2$mean_H2Omg~s2$Na)
abline(mod)
summary(mod)


```{r}
## Import annotation documents 
#annos <- read_delim("data/annos.txt", delim = "\t", 
#+     escape_double = FALSE, col_names = FALSE, 
#+     locale = locale(), trim_ws = TRUE)
annos <- read_csv("/Users/danielleblumstein/Documents/UNH/rnaseq/dehy_final/data/annos.txt")

library("org.Hs.eg.db")
annos$ensid = mapIds(org.Hs.eg.db,
                    keys=annos$gene, 
                    column="ENSEMBL",
                    keytype="SYMBOL",
                    multiVals="first")
```


```{r}
countdata <- data.frame(annos$transcript)
colnames(countdata) <- "transcript"
for (counts in (1:length(samples$filename)))
  {
  # import data for that sample
  toimport <- samples$filename[counts]
  tmpdata <- read.table(paste0("data/", toimport), header = FALSE, sep = "\t")
  # sample id
  samplename <- toimport  %>% gsub(pattern = ".gene.counts", replacement = "")
  samplename <- gsub("_S.*", "", samplename)
  colnames(tmpdata) <- c("transcript", samplename)
  countdata <- dplyr::left_join(countdata, tmpdata, by = "transcript")
}
dim(countdata)
countdata <- data.frame(countdata, row.names = 1)
names(countdata)=str_sub(names(countdata),2)
countdata

write.csv(countdata, "countdata.csv", row.names = FALSE)
```


Quick data control. Change any "NA" values to "0"
```{r data QC}
# change all NA to 0
print(paste0("Number of NA after import:", sum(is.na(countdata))))
countdata[is.na(countdata)] <-  0
print(paste0("Number of NA after NA removal:", sum(is.na(countdata))))
print(paste0("Number of genes after import:", nrow(countdata)))

## remove all unknown proteins
countdata <- countdata[!rownames(countdata) == "proteins of unknown function", ]
print(paste("Number of genes after removing all 'proteins of unknown function':", nrow(countdata)))

dim(countdata)
countdata
```


The count data table is currently a dataframe of counts, with each row representing a transcript in the genome. Some genes are represented by multiple transcripts in the genome, and hence our count data table. Here I will manipulate the data so that we can do a gene level analysis.

```{R Create a data frame of gene level count data}
# make rownames column 1
countdata <- setDT(countdata, keep.rownames = "transcript")[]

# add gene symbol
countdata2 <- dplyr::left_join(annos, countdata, by = "transcript")
dim(countdata2)

# change all NA to 0
print(paste("Number of NA after import:", sum(is.na(countdata2))))

countdata2 <- countdata2 %>% 
    dplyr::mutate_at(5:163, ~replace_na(.,0))

# combine all counts that map to the same gene
countdata3 <- aggregate(countdata2[, 5:163], list(countdata2$gene), sum)
dim(countdata3)

countdata3[is.na(countdata3)] <-  0
colnames(countdata3)[1] <- "Gene"
countdata <- countdata3

# make gene name column
countdata <- data.frame(countdata, row.names = 1)
print(paste("Number of genes after combining all counts that map to the same gene:", nrow(countdata)))

for ( col in 1:ncol(countdata)){
    colnames(countdata)[col] <-  sub("X*", "", colnames(countdata)[col])
}

# save gene-level count data
write.table(countdata, "data/gene.level.count.data.tsv", row.names = TRUE, sep = "\t")
```

t tests
```{r}
pro_weight_F_yes <-samples %>% filter(sex == "F") 
pro_weight_F_yes <-pro_weight_F_yes %>% filter(trt == "yes") 

pro_weight_F_no <-samples %>% filter(sex == "F") 
pro_weight_F_no <-pro_weight_F_no %>% filter(trt == "no") 

t.test(pro_weight_F_no$pro_weight, pro_weight_F_yes$pro_weight)


pro_weight_M_yes <-samples %>% filter(sex == "M") 
pro_weight_M_yes <-pro_weight_M_yes %>% filter(trt == "yes") 

pro_weight_M_no <-samples %>% filter(sex == "M") 
pro_weight_M_no <-pro_weight_M_no %>% filter(trt == "no") 

t.test(pro_weight_M_no$pro_weight, pro_weight_M_yes$pro_weight)


meanEE_F_yes <-samples %>% filter(sex == "F") 
meanEE_F_yes <-meanEE_F_yes %>% filter(trt == "yes") 

meanEE_F_no <-samples %>% filter(sex == "F") 
meanEE_F_no <-meanEE_F_no %>% filter(trt == "no") 

t.test(meanEE_F_no$mean_EE, meanEE_F_yes$mean_EE)

meanEE_M_yes <-samples %>% filter(sex == "M") 
meanEE_M_yes <-meanEE_M_yes %>% filter(trt == "yes") 

meanEE_M_no <-samples %>% filter(sex == "M") 
meanEE_M_no <-meanEE_M_no %>% filter(trt == "no") 

t.test(meanEE_M_no$mean_EE, meanEE_M_yes$mean_EE)

meanRQ_F_yes <-samples %>% filter(sex == "F") 
meanRQ_F_yes <-meanRQ_F_yes %>% filter(trt == "yes") 

meanRQ_F_no <-samples %>% filter(sex == "F") 
meanRQ_F_no <-meanRQ_F_no %>% filter(trt == "no") 

t.test(meanRQ_F_no$mean_RQ, meanRQ_F_yes$mean_RQ)

meanRQ_M_yes <-samples %>% filter(sex == "M") 
meanRQ_M_yes <-meanRQ_M_yes %>% filter(trt == "yes") 

meanRQ_M_no <-samples %>% filter(sex == "M") 
meanRQ_M_no <-meanRQ_M_no %>% filter(trt == "no") 

t.test(meanRQ_M_no$mean_RQ, meanRQ_M_yes$mean_RQ)

meanH2O_F_yes <-samples %>% filter(sex == "F") 
meanH2O_F_yes <-meanH2O_F_yes %>% filter(trt == "yes") 

meanH2O_F_no <-samples %>% filter(sex == "F") 
meanH2O_F_no <-meanH2O_F_no %>% filter(trt == "no") 

t.test(meanH2O_F_no$mean_H2Og, meanH2O_F_yes$mean_H2Og)

meanH2O_M_yes <-samples %>% filter(sex == "M") 
meanH2O_M_yes <-meanH2O_M_yes %>% filter(trt == "yes") 

meanH2O_M_no <-samples %>% filter(sex == "M") 
meanH2O_M_no <-meanH2O_M_no %>% filter(trt == "no") 

t.test(meanH2O_M_no$mean_H2Og, meanH2O_M_yes$mean_H2Og)

```

### DESeq data creation 
```{r DESEQ creation}

all(rownames(samples) %in% colnames(countdata))
all(rownames(samples) == colnames(countdata))

# crea DESeq dataset
dds <- DESeqDataSetFromMatrix(countData = countdata,
                                       colData = samples,
                                       design = ~ sex + tissue + trt)

dds <- estimateSizeFactors(dds)
idx <- rowSums(counts(dds, normalized=TRUE) >= 10 ) >= 8

dds <- dds[idx,]
```


### Crea a PCA

```{R PCA}
vsd <- varianceStabilizingTransformation(dds, blind = FALSE)
# get PC1 and PC2 data
pcaData <- plotPCA(vsd, intgroup = c("sex", "tissue", "trt"), returnData = TRUE)
# get percent variation
percentVar <- round(100 * attr(pcaData, "percentVar"))
# pca code
pca <- ggplot(pcaData, aes(x = PC1, y = PC2, color = tissue, shape = trt, name=name)) +
  stat_ellipse(aes(group = tissue, linetype = tissue), type = "t", level = 0.95, size = 1.25, show.legend = FALSE) +
  #scale_linetype_manual(values=c("twodash", "longdash", "solid"), guide = FALSE) +
  geom_point(size = 3, show.legend = TRUE) + 
  #scale_color_manual(values = c("orange1", "red1", "yellow2", "chartreuse4")) +
  #scale_shape_manual(values = c(8,9,15,16,10,17,18,11,13)) + 
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  coord_fixed() + theme_bw() +
  guides(shape = guide_legend(order = 1),color = guide_legend(order = 2)) 
# save
ggsave("figures/PCA.png", width = 8, height = 4.6, dpi = 600)


library(plotly)
ggplotly(pca)
```


### Make the final PCA for the publication

```{R PCA for publication}
# pca code
ggplot(pcaData, aes(x = PC1, y = PC2, color = tissue, shape = trt)) +
  stat_ellipse(aes(group = tissue, linetype = tissue), type = "t", level = 0.95, size = 1.25, show.legend = FALSE) +
  #scale_linetype_manual(values=c("twodash", "longdash", "solid"), guide = FALSE) +
  geom_point(size = 3, show.legend = TRUE) + 
  #scale_color_manual(values = c("orange1", "red1", "yellow2", "chartreuse4")) +
  #scale_shape_manual(values = c(8,9,15,16,10,17,18,11,13)) + 
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  coord_fixed() + theme_bw() +
  guides(shape = guide_legend(order = 1),color = guide_legend(order = 2)) 
  
ggsave("figures4publication/PCA.png", width = 8, height = 4.6, dpi = 600)
```


### Crea a heatmap
```{r HEATWAVE, eval = FALSE}
# crea sample distances and sample distance matrix
sampleDists <- dist(t(assay(vsd)))
sampleDistMatrix <- as.matrix( sampleDists )


# plot heatmap
heatmapcolors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix, clusr_rows = FALSE, clusr_cols = FALSE, col = heatmapcolors)
# plot and save heatmap
png("figures/heatmap.png", width = 14.63, height = 10, units = "in", res = 600)
dev.off()
```

### Differential expression analyses

I will run some differential expression analyses now. I want to account for sex, trt, and tissue in my analyses.


Run differential expression analysis. What is the effect of sex?
```{r LRT sex, eval = FALSE}
ddssex <- DESeqDataSetFromMatrix(countData = countdata,
                                       colData = samples,
                                       design = ~ trt + tissue + sex)

ddssex <- estimateSizeFactors(ddssex)
idx <- rowSums(counts(ddssex, normalized=TRUE) >= 10 ) >= 8

ddssex <- ddssex[idx,]
print(paste("Number of genes after filtering by total expression:", nrow(ddssex)))

# run LRT test
ddssex <- DESeq(ddssex, test="LRT", reduced = ~ trt + tissue)
ressex <- results(ddssex)
ressex$transcript <- mcols(ressex)$transcript
# how many are "significant"?
table(ressex[,"padj"] < 0.05)
res05 <- results(ddssex, alpha=0.05)
summary(res05)
```

```{r LRT tissue, eval = FALSE}
ddstissue <- DESeqDataSetFromMatrix(countData = countdata,
                                       colData = samples,
                                       design = ~ trt + sex + tissue)

ddstissue <- estimateSizeFactors(ddstissue)
idx <- rowSums(counts(ddstissue, normalized=TRUE) >= 10 ) >= 8

ddstissue <- ddstissue[idx,]
print(paste("Number of genes after filtering by total expression:", nrow(ddstissue)))

# run LRT test
ddstissue <- DESeq(ddstissue, test="LRT", reduced = ~ trt + sex)
restissue <- results(ddstissue)
restissue$symbol <- mcols(restissue)$symbol
# how many are "significant"?
table(restissue[,"padj"] < 0.05)
summary(restissue)
```

```{r}
ddstrt <- DESeqDataSetFromMatrix(countData = countdata,
                                       colData = samples,
                                       design = ~ sex + tissue + trt)

ddstrt <- estimateSizeFactors(ddstrt)
idx <- rowSums(counts(ddstrt, normalized=TRUE) >= 10 ) >= 8

ddstrt <- ddstrt[idx,]
print(paste("Number of genes after filtering by total expression:", nrow(ddstrt)))

# run LRT test
ddstrt <- DESeq(ddstrt, test="LRT", reduced = ~ tissue + sex)
restrt <- results(ddstrt)
restrt$symbol <- mcols(restrt)$symbol
# how many are "significant"?
table(restrt[,"padj"] < 0.001)

write.table(restrt, file="restrt.csv", quote=F)

ddstrt <- DESeq(ddstrt,test="Wald")
annos$ensembl <- as.character(annos$ensid)

#rename transcript rows to ensid names
rownames(ddstrt)=annos$ensid[match(names(ddstrt),annos$gene)]
#remove the NAs (those transcripts dont have a ensid name)
ddstrt <- ddstrt[complete.cases(rownames(ddstrt)), ]
ddstrt <- ddstrt[!rownames(ddstrt) == "NULL", ] 
rownames(ddstrt)=annos$gene[match(names(ddstrt),annos$ensid)]

ddstrt <- estimateSizeFactors(ddstrt)
normalized_counts <- vst(ddstrt, blind = FALSE)
all_Expr <- assay(normalized_counts)
#all_Expr<- as.data.frame(all_Expr)
#all_Expr <- tibble::rownames_to_column(all_Expr, "ID")

library(caroline)
write.delim(all_Expr, "data/normalized.count.data.txt", sep = '\t')


all_Expr<- as.matrix(all_Expr)
heatmap(all_Expr,
        Rowv=NA, Colv=NA, col=rev(brewer.pal(9,"RdBu")))
```

```{r}
require(GGally)
library(vegan)

genes_for_cca <- read_csv("results/WGCNAresults/genes_for_cca.csv", col_names = FALSE)
all_Expr<- as.data.frame(all_Expr)

#subset_all_Expr <- all_Expr %>% filter(rownames(all_Expr) %in% genes_for_cca$X1)

t_subset_all_Expr <-t(all_Expr)
samples<-as.data.frame(samples)
traitData_V2 <- samples %>% dplyr::select(c("trt","pro_weight","mean_RQ","mean_EE","mean_H2Og","body_temp_3","sample","tissue", "sex","Animal_ID"))

#traitData_V2 <- traitData_V2 |>
 #   mutate(tt = fct_cross(trt, sex, tissue))

traitData_V2$trt <- as.factor(traitData_V2$trt)
traitData_V2$sex <- as.factor(traitData_V2$sex)
rownames(traitData_V2) <- traitData_V2$sample
traitData_V2 <- subset(traitData_V2, select = -sample)
traitData_V2$tissue <- as.factor(traitData_V2$tissue)
traitData_V2$Animal_ID <- as.factor(traitData_V2$Animal_ID)

#ggpairs(traitData_V2)

cca_model <- cca(t_subset_all_Expr ~ trt+pro_weight+mean_RQ+mean_EE+mean_H2Og+body_temp_3 +sex +tissue,data = traitData_V2)

#anova the model to find the significance of the terms
#anova(cca_model)
#anova(cca_model,by="terms")
#anova(cca_model,by="axis")
#anova(cca_model, by = "margin")

#Get CCA scores
df_species  <- data.frame(summary(cca_model)$species[,1:2])# get the genes CC1 and CC2 scores

sd <- sd(df_species$CCA1)
out_ind1 <- df_species %>% filter(CCA1 > sd*2)
out_ind2 <- df_species %>% filter(CCA1 < -(sd*2))

sd <- sd(df_species$CCA2)
out_ind3 <- df_species %>% filter(CCA2 > sd*3)
out_ind4 <- df_species %>% filter(CCA2 < -(sd*3))

#put the 3sd (99% confidence) from the genes are in a GO analysis
out <- distinct(rbind(out_ind1,out_ind2,out_ind3,out_ind4))

write.table(out, "results/cca_outliers.csv", row.names = TRUE, sep = "\t")
out$color <- "outlier"

norm <- df_species[!(row.names(df_species) %in% rownames(out)),]
norm$color <- "in bound"

graphing_data <- as.data.frame(rbind(norm,out))

df_sites  <- data.frame(summary(cca_model)$sites[,1:2])# get the indivisuals CC1 and CC2 scores
df_environ  <- data.frame(scores(summary(cca_model)$biplot[c(2,5),1:2])) #get the physio vars CC1 and CC2 scores

df_tissue  <- scores(summary(cca_model)$centroids[,1:2]) #get the tissue centriod vars CC1 and CC2 scores


rc <- function (u) paste0(u[c(3,4)], collapse = "_")
#make col names just the tissue, sex, trt
df_sites$lable <- unlist(lapply(strsplit(rownames(df_sites), split = "_"),rc))

CCA1_varex<-round(summary(cca_model)$cont$importance[2,1]*100,2) #Get percentage of variance explained by first axis
CCA2_varex<-round(summary(cca_model)$cont$importance[2,2]*100,2) #Get percentage of variance explained by second axis

#Set a scaling variable to multiply the CCA values, in order to get a very similar plot to the the one generated by plot(cca_model). You can adjust it according to your data
scaling_factor <- 2
library(paletteer)

cca_plot <- ggplot(df_species, 
       aes(x=CCA1, y=CCA2)) + 
  #Draw lines on x = 0 and y = 0
  geom_hline(yintercept=0, 
             linetype="dashed") +
  geom_vline(xintercept=0, 
             linetype="dashed") +
  #coord_fixed()+
  #Add species text
    geom_text(data=graphing_data, 
            aes(x=CCA1,#Score in CCA1 to add species text
                y=CCA2,#Score in CCA2 to add species text
                label=rownames(graphing_data),
                hjust=0.5*(1-sign(CCA1)),#Set the text horizontal alignment according to its position in the CCA plot
                vjust=0.5*(1-sign(CCA2)),
                color=factor(color)),#Set the text vertical alignment according to its position in the CCA plot
            #color = c("darkorange","forestgreen"),
            size = 10/.pt)+
  #Add sites text
  geom_point(data=df_sites, 
            aes(col = df_sites$lable,
                x=CCA1,#Score in CCA1 to add species text
                y=CCA2))+#Score in CCA2 to add species text
  #Add environmental vars arrows
  geom_segment(data=df_environ, 
               aes(x=0, #Starting coordinate in CCA1 = 0 
                   xend=CCA1*scaling_factor,#Ending coordinate in CCA1  
                   y=0, #Start in CCA2 = 0
                   yend=CCA2*scaling_factor), #Ending coordinate in CCA2 
               color="black", #set color
               arrow=arrow(length=unit(0.01,"npc"))#Set the size of the lines that form the tip of the arrow
               )+
  #Add environmental vars text
  geom_text(data=df_environ, 
            aes(x=CCA1*scaling_factor, 
                y=CCA2*scaling_factor,
                label=rownames(df_environ),
                hjust=0.5*(1-sign(CCA1)),#Add the text of each environmental var at the end of the arrow
                vjust=0.5*(1-sign(CCA2))),#Add the text of each environmental var at the end of the arrow 
            color="black")+
  #Set bw theme
  theme_bw()+
  scale_color_paletteer_d("ggthemes_ptol::qualitative", 12,direction = 1)+
  xlim(-0.8, 0.5)+
  ylim(-0.4, 0.7)+
  #Set x and y axis titles
  labs(x=paste0("CCA1 (",CCA1_varex," %)"),
       y=paste0("CCA2 (",CCA2_varex," %)"))

cca_plot
```



```{r}
rownames(out)
library(gprofiler2)
#library(gProfileR)

gostres <- gost(query = rownames(out), 
                organism = "hsapiens", ordered_query = FALSE, 
                multi_query = FALSE, significant = TRUE, exclude_iea = FALSE, 
                measure_underrepresentation = FALSE, evcodes = FALSE, 
                user_threshold = 0.05, correction_method = "g_SCS", 
                domain_scope = "annotated", custom_bg = NULL, 
                numeric_ns = "", sources = NULL, as_short_link = FALSE, highlight = TRUE)

gostplot(gostres, capped = TRUE, interactive = TRUE)

```


## now you have normalized read counts - yay!
```{r}
for ( col in 1:ncol(kid_Expr)){
    colnames(kid_Expr)[col] <-  sub("X", "", colnames(kid_Expr)[col])
}

for ( col in 1:ncol(liv_Expr)){
    colnames(liv_Expr)[col] <-  sub("X", "", colnames(liv_Expr)[col])
}

for ( col in 1:ncol(lu_Expr)){
    colnames(lu_Expr)[col] <-  sub("X", "", colnames(lu_Expr)[col])
}

for ( col in 1:ncol(gi_Expr)){
    colnames(gi_Expr)[col] <-  sub("X", "", colnames(gi_Expr)[col])
}

for ( col in 1:ncol(hyp_Expr)){
    colnames(hyp_Expr)[col] <-  sub("X", "", colnames(hyp_Expr)[col])
}
#,hyp_Expr,lu_Expr,gi_Expr,
lst <- list(kid_Expr,hyp_Expr)
genes_to_keep <- Reduce(intersect, lapply(lst, rownames))

filteredkid <- kid_Expr[rownames(kid_Expr) %in% genes_to_keep,]
#filteredliv <- liv_Expr[rownames(liv_Expr) %in% genes_to_keep,]
#filteredlu <- lu_Expr[rownames(lu_Expr) %in% genes_to_keep,]
#filteredgi <- gi_Expr[rownames(gi_Expr) %in% genes_to_keep,]
filteredhyp <- hyp_Expr[rownames(hyp_Expr) %in% genes_to_keep,]

#"liv","lu","gi"
nSets <- 2
setLabels = c("kid","hyp")
multiExpr = vector(mode = "list", length = nSets)

# load the expression variables in multiExpr
multiExpr[[1]] = list(data = as.data.frame(t(filteredkid)))
#multiExpr[[2]] = list(data = as.data.frame(t(filteredliv)))
#multiExpr[[3]] = list(data = as.data.frame(t(filteredlu)))
#multiExpr[[4]] = list(data = as.data.frame(t(filteredgi)))
multiExpr[[2]] = list(data = as.data.frame(t(filteredhyp)))
# For easier labeling of plots, create a vector holding descriptive names of the two sets.

names(multiExpr) = setLabels
lapply(multiExpr, lapply, dim)

exprSize = checkSets(multiExpr)
```

```{r}
sampleTrees = list()
for (set in 1:nSets)
{
sampleTrees[[set]] = hclust(dist(multiExpr[[set]]$data), method = "average")
}

par(mfrow=c(5,1))
par(mar = c(0, 4, 2, 0))
for (set in 1:nSets)
{
plot(sampleTrees[[set]], main = paste("Sample clustering on all genes in", setLabels[set]),xlab="", sub="", cex = 0.7)
}
```


```{r}
# Trait data generation ---------------------------------------------------
# Now we read in the phenotypic trait data
traitData <- as.data.frame(samples)
#traitData <- 'row.names<-'(samples, samples$sample)
traitData$trt <- as.numeric(as.factor(traitData$trt))
traitData$sex <- as.numeric(as.factor(traitData$sex))

# Choose columns of trait dataset to be used in downstream analyses
colnames(traitData)
traitData <- traitData %>% dplyr::select(c("sample",'sex','total_weight_delta',"pro_weight","Na","BUN","AnGap","K","Crea","Hct","Cl","Glu","Hb*","TCO2","iCa","trt","mean_RQ","mean_EE","mean_H2Og","body_temp_3"))
#traitData <- as.data.frame(lapply(traitData, as.numeric))

# Form a multi-set structure that will hold the traits.
Traits = vector(mode="list", length = nSets)
for (set in 1:nSets)
{
setSamples = rownames(multiExpr[[set]]$data)
traitRows = match(setSamples, traitData$sample)
Traits[[set]] = list(data = traitData[traitRows, -1])
Traits[[set]] <- subset(Traits[[set]]$data, select=-c(sample))
}
collectGarbage()

# Define data set dimensions
nGenes = exprSize$nGenes;
nSamples = exprSize$nSamples;

save(multiExpr, Traits, nGenes, nSamples, setLabels, exprSize,file = "Consensus-dataInput.RData")
```

```{r}
lnames = load(file = "Consensus-dataInput.RData");

# The variable lnames contains the names of loaded variables.
lnames
# Get the number of sets in the multiExpr structure.
nSets = checkSets(multiExpr)$nSets
```

```{r}

# Choose a set of soft-thresholding powers
powers = c(seq(4,10,by=1), seq(12,20, by=2));
# Initialize a list to hold the results of scale-free analysis
powerTables = vector(mode = "list", length = nSets);
# Call the network topology analysis function for each set in turn
for (set in 1:nSets)
powerTables[[set]] = list(data = pickSoftThreshold(multiExpr[[set]]$data, powerVector=powers,verbose = 2)[[2]]);
collectGarbage();
# Plot the results:
colors = c("black", "red")
# Will plot these columns of the returned scale free analysis tables
plotCols = c(2,5,6,7)
colNames = c("Scale Free Topology Model Fit", "Mean connectivity", "Median connectivity",
"Max connectivity");
# Get the minima and maxima of the plotted points
ylim = matrix(NA, nrow = 2, ncol = 4);

for (set in 1:nSets)
{
for (col in 1:length(plotCols))

{
ylim[1, col] = min(ylim[1, col], powerTables[[set]]$data[, plotCols[col]], na.rm = TRUE);
ylim[2, col] = max(ylim[2, col], powerTables[[set]]$data[, plotCols[col]], na.rm = TRUE);
}
}

# Plot the quantities in the chosen columns vs. the soft thresholding power
sizeGrWindow(8, 6)
#pdf(file = "Plots/scaleFreeAnalysis.pdf", wi = 8, he = 6)
par(mfcol = c(2,2));
par(mar = c(4.2, 4.2 , 2.2, 0.5))
cex1 = 0.7;
for (col in 1:length(plotCols)) for (set in 1:nSets)
{
if (set==1)
{
plot(powerTables[[set]]$data[,1], -sign(powerTables[[set]]$data[,3])*powerTables[[set]]$data[,2],
xlab="Soft Threshold (power)",ylab=colNames[col],type="n", ylim = ylim[, col],
main = colNames[col]);
addGrid();
}
if (col==1)
{
text(powerTables[[set]]$data[,1], -sign(powerTables[[set]]$data[,3])*powerTables[[set]]$data[,2],
labels=powers,cex=cex1,col=colors[set]);
} else
text(powerTables[[set]]$data[,1], powerTables[[set]]$data[,plotCols[col]],
labels=powers,cex=cex1,col=colors[set]);
if (col==1)
{
legend("bottomright", legend = setLabels, col = colors, pch = 20) ;
} else
legend("topright", legend = setLabels, col = colors, pch = 20) ;
}
```

```{r}
net = blockwiseConsensusModules(multiExpr, power = 14, minModuleSize = 30, deepSplit = 2,pamRespectsDendro = FALSE,mergeCutHeight = 0.25, numericLabels = F,minKMEtoStay = 0,saveTOMs = TRUE, verbose = 5, maxBlockSize=14000,)
```




```{r}
consMEs = net$multiMEs;
moduleLabels = net$colors;
# Convert the numeric labels to color labels
moduleColors = labels2colors(moduleLabels)
consTree = net$dendrograms[[1]];

sizeGrWindow(8,6);
#pdf(file = "Plots/ConsensusDendrogram-auto.pdf", wi = 8, he = 6)
plotDendroAndColors(consTree, moduleColors,"Module colors",dendroLabels = FALSE, hang = 0.03,addGuide = TRUE, guideHang = 0.05,main = "Consensus gene dendrogram and module colors")
```

```{r}
MEColors = substring(names(consMEs[[1]]$data), 3);
MEColorNames = paste("ME", MEColors, sep="");

# Set up variables to contain the module-trait correlations
moduleTraitCor = list();
moduleTraitPvalue = list();

# Calculate the correlations
for (set in 1:nSets)
{
moduleTraitCor[[set]] = cor(consMEs[[set]]$data, Traits[[set]], use = "p");
moduleTraitPvalue[[set]] = corPvalueFisher(moduleTraitCor[[set]], exprSize$nSamples[set]);
}



# Initialize matrices to hold the consensus correlation and p-value
consensusCor = matrix(NA, nrow(moduleTraitCor[[1]]), ncol(moduleTraitCor[[1]]));
consensusPvalue = matrix(NA, nrow(moduleTraitCor[[1]]), ncol(moduleTraitCor[[1]]));

# Find consensus negative correlations
negative = moduleTraitCor[[1]] < 0 & moduleTraitCor[[2]] < 0 

#& moduleTraitCor[[3]] < 0 & moduleTraitCor[[4]] < 0 & moduleTraitCor[[5]] < 0;

consensusCor[negative] = pmax(moduleTraitCor[[1]][negative], moduleTraitCor[[2]][negative])
                              
#, moduleTraitCor[[3]][negative],moduleTraitCor[[4]][negative],moduleTraitCor[[5]][negative]);

consensusPvalue[negative] = pmax(moduleTraitPvalue[[1]][negative], moduleTraitPvalue[[2]][negative])
                                 #,moduleTraitPvalue[[3]][negative],moduleTraitPvalue[[4]][negative],moduleTraitPvalue[[5]][negative]);

# Find consensus positive correlations
positive = moduleTraitCor[[1]] > 0 & moduleTraitCor[[2]] > 0 


#& moduleTraitCor[[3]] > 0 & moduleTraitCor[[4]] > 0 & moduleTraitCor[[5]] > 0;

consensusCor[positive] = pmin(moduleTraitCor[[1]][positive], moduleTraitCor[[2]][positive])
                              
#,moduleTraitCor[[3]][positive],moduleTraitCor[[4]][positive],moduleTraitCor[[5]][positive]);

consensusPvalue[positive] = pmax(moduleTraitPvalue[[1]][positive], moduleTraitPvalue[[2]][positive])
                                 #,moduleTraitPvalue[[3]][positive],moduleTraitPvalue[[4]][positive],moduleTraitPvalue[[5]][positive]);

textMatrix = paste(signif(consensusCor, 2), "\n(",signif(consensusPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor[[set]])


#pdf(file = "figures/ModuleTraitRelationships-consensus.pdf", wi = 10, he = 7);

dev.off()
par(mar = c(6, 8.8, 3, 2.2));
labeledHeatmap(Matrix = consensusCor,xLabels = names(Traits[[set]]),yLabels = MEColorNames,ySymbols = MEColorNames,colorLabels = FALSE,colors = blueWhiteRed(50),textMatrix = textMatrix,setStdMargins = FALSE,cex.text = 0.5,zlim = c(-1,1),main = paste("Consensus module--trait relationships across\n",paste(setLabels, collapse = " and ")))

```


```{r}
annot = annos
# Match probes in the data set to the probe IDs in the annotation file
probes = names(multiExpr[[1]]$data)
probes2annot = match(probes, annot$gene)

consMEs.unord = multiSetMEs(multiExpr, universalColors = moduleLabels, excludeGrey = TRUE)
GS = list();
kME = list();
for (set in 1:nSets)
{
GS[[set]] = corAndPvalue(multiExpr[[set]]$data, Traits[[set]]$data);
kME[[set]] = corAndPvalue(multiExpr[[set]]$data, consMEs.unord[[set]]$data);
}

GS.metaZ = (GS[[1]]$Z + GS[[2]]$Z)/sqrt(2);
kME.metaZ = (kME[[1]]$Z + kME[[2]]$Z)/sqrt(2);
GS.metaP = 2*pnorm(abs(GS.metaZ), lower.tail = FALSE);
kME.metaP = 2*pnorm(abs(kME.metaZ), lower.tail = FALSE);

#GSmat = rbind(GS[[1]]$cor, GS[[2]]$cor, GS[[1]]$p, GS[[2]]$p, GS.metaZ, GS.metaP);
#nTraits = checkSets(Traits)$nGenes
#traitNames = colnames(Traits[[1]]$data)
#dim(GSmat) = c(nGenes, 6*nTraits)
#rownames(GSmat) = probes;
#colnames(GSmat) = spaste(c("GS.set1.", "GS.set2.", "p.GS.set1.", "p.GS.set2.", "Z.GS.meta.", #"p.GS.meta"),rep(traitNames, rep(6, nTraits)))

# Same code for kME:
kMEmat = rbind(kME[[1]]$cor, kME[[2]]$cor, kME[[1]]$p, kME[[2]]$p, kME.metaZ, kME.metaP);
MEnames = colnames(consMEs.unord[[1]]$data);
nMEs = checkSets(consMEs.unord)$nGenes
dim(kMEmat) = c(nGenes, 6*nMEs)
rownames(kMEmat) = probes;
colnames(kMEmat) = spaste(c("kME.set1.", "kME.set2.", "p.kME.set1.", "p.kME.set2.", "Z.kME.meta.", "p.kME.meta"),rep(MEnames, rep(6, nMEs)))

info = data.frame(Probe = probes, GeneSymbol = annot$gene[probes2annot],EntrezID = annot$ensembl[probes2annot],ModuleLabel = moduleLabels,ModuleColor = labels2colors(moduleLabels),kMEmat);

write.csv(info, file = "consensusAnalysis-CombinedNetworkResults_kid_hyp.csv",row.names = FALSE, quote = FALSE);
```

```{r}
color = "cyan"

wgcna <- info$EntrezID[which(info$ModuleLabel==color)]
ddstrt1 <- subset(ddstrt, rownames(ddstrt) %in% wgcna)


restrt <- results(ddstrt1, alpha = 0.01, contrast = c("trt", "yes", "no"))
restrt$transcript <- mcols(restrt)$transcript
restrt$symbol <- mcols(restrt)$symbol

restrt$EntrezID <- sapply( strsplit( rownames(restrt), split="\\+" ), "[", 1 )
#ensembl = useMart( "ensembl", dataset = "hsapiens_gene_ensembl" )

#querying with the ENSEMBL gene id and requesting the Entrez gene id and HGNC gene symbol.
genemap <- getBM( attributes = c("ensembl_gene_id", "hgnc_symbol"),
                  filters = "ensembl_gene_id",
                  values = rownames(restrt),
                  mart = ensembl)

idx <- match(rownames(restrt), genemap$ensembl_gene_id )
restrt$hgnc_symbol <- genemap$hgnc_symbol[ idx ]
hgnc_symbol <- restrt$hgnc_symbol

mcols(ddstrt1) <- cbind(mcols(ddstrt1), hgnc_symbol)
restrt$hgnc_symbol <- rowData(ddstrt1)$hgnc_symbol

ddstrt1 <- estimateSizeFactors(ddstrt1)

anno_df <- data.frame(gene_id = restrt$EntrezID, gene_name = restrt$hgnc_symbol)
vst_macrophage <- varianceStabilizingTransformation(ddstrt1)

bg_ids <- rownames(ddstrt1)[rowSums(counts(ddstrt1)) > 0]
bg_symbols <- mapIds(org.Hs.eg.db,
                     keys = bg_ids,
                     column = "SYMBOL",
                     keytype = "ENSEMBL",
                     multiVals = "first")
 
# res_enrich object
#library("AnnotationDbi")
de_symbols_IFNg_vs_naive <- deseqresult2df(restrt, FDR =0.05)$hgnc_symbol

# res_enrich object ------------------------------------------------------------
 topgoDE <-
  pcaExplorer::topGOtable(de_symbols_IFNg_vs_naive,
                          bg_symbols,
                          ontology = "BP",
                          mapping = "org.Hs.eg.db",
                          geneID = "symbol",
                          topTablerows = 30)

res_enrich <- shake_topGOtableResult(topgoDE)
res_enrich_mod <- get_aggrscores(res_enrich = res_enrich,
                                        res_de = restrt,
                                        annotation_obj = anno_df,
                                        aggrfun = mean)


GeneTonic(dds = ddstrt1,
          res_de = restrt,
          res_enrich = res_enrich_mod,
          annotation_obj = anno_df,
          project_id = "myFirstGeneTonic")


res_enrich_mod$mod <- color
write.csv(res_enrich_mod, file=paste0("results/WGCNAresults/kid_hyp_wgcna_GO",color,".csv"))
```

Now I will run these test for each tissue independently. 
in a new script, one per tissue cause life

after running the individual tissue scripts take advantage of the fact that it is in Rs global enviroment and come back to this stuff
```{r}
compa_list <- list(
  gi = res_enrich_gi,
  lu = res_enrich_lu,
  liv = res_enrich_liv
)

gs_horizon(res_enrich_all,
           compared_res_enrich_list = compa_list,
           n_gs = 30,
           sort_by = "clustered")


lu <- PCA_graph(lu_dds_trt, "lu")
liv <- PCA_graph(liv_dds_trt, "liv")
hyp <- PCA_graph(hyp_dds_trt, "hyp")
gi <- PCA_graph(gi_dds_trt, "gi")
all <- PCA_graph(all_dds_trt, "all")

lu+liv+hyp+gi+ all
```

upsetR
number of GO terms overlapping each tissue
```{r}
#res_enrich_hyp1 <- dplyr::select(res_enrich_hyp, gs_id, DE_count)
#res_enrich_hyp1$hyp <- as.integer(res_enrich_hyp1$DE_count)
#res_enrich_hyp1$DE_count <- NULL

res_enrich_all1 <- dplyr::select(res_enrich_all, gs_id, DE_count)
res_enrich_all1$all <- as.integer(res_enrich_all1$DE_count)
res_enrich_all1$DE_count <- NULL

res_enrich_liv1 <- dplyr::select(res_enrich_liv, gs_id, DE_count)
res_enrich_liv1$liv <- as.integer(res_enrich_liv1$DE_count)
res_enrich_liv1$DE_count <- NULL

res_enrich_lu1 <- dplyr::select(res_enrich_lu, gs_id, DE_count)
res_enrich_lu1$lu <- as.integer(res_enrich_lu1$DE_count)
res_enrich_lu1$DE_count <- NULL

res_enrich_gi1 <- dplyr::select(res_enrich_gi, gs_id, DE_count)
res_enrich_gi1$gi <- as.integer(res_enrich_gi1$DE_count)
res_enrich_gi1$DE_count <- NULL

df_list <- list(res_enrich_all1, res_enrich_liv1, res_enrich_lu1, res_enrich_gi1)

# merge all data frames and move the common column to first position and keep all other columns
newdf <- df_list %>% purrr::reduce(full_join, by='gs_id') %>% 
dplyr::select(gs_id, everything())

newdf[is.na(newdf)] = 0
newdf[newdf > 0] <- 1

library(UpSetR)
upset(newdf, sets = c("all", "liv", "lu", "gi"), mb.ratio = c(0.55, 0.45), order.by = "freq")

countdata1<-countdata

multi_fun <- function(x){
  cat <- paste(x[3:4], collapse = "_")
  
}
test <- strsplit(colnames(countdata1), split = "_")
colnames(countdata1)<-sapply(test,multi_fun)

countdata1[is.na(countdata1)] = 0
countdata1[countdata1 > 0] <- 1

unique(colnames(countdata1))
upset(countdata1, sets = c("gi_yes","hyp_yes","all_yes",
                           "liv_yes","lu_yes","gi_no",
                           "hyp_no","liv_no","lu_no","all_no" ), 
                          mb.ratio = c(0.55, 0.45), order.by = "freq")



#"F_gi_yes","F_hyp_yes","F_all_yes",
#"F_liv_yes","F_lu_yes" ,"F_gi_no",
#"F_hyp_no","F_liv_no","F_lu_no",
#"F_all_no","M_liv_yes","M_all_yes",
#"M_lu_yes","M_gi_yes","M_hyp_yes",
#"M_hyp_no","M_all_no","M_liv_no","M_gi_no","M_lu_no"
```


upsetR
number of genes overlapping each tissue
```{r}
restrt_all<- as.data.frame(restrt_all)
restrt_all$gene <- rownames(restrt_all)

restrt_liv<- as.data.frame(restrt_liv)
restrt_liv$gene <- rownames(restrt_liv)

restrt_lu<- as.data.frame(restrt_lu)
restrt_lu$gene <- rownames(restrt_lu)

restrt_gi<- as.data.frame(restrt_gi)
restrt_gi$gene <- rownames(restrt_gi)

res_enrich_all1 <- dplyr::select(restrt_all, gene, pvalue)
res_enrich_all1$all <- as.integer(res_enrich_all1$pvalue) + 1
res_enrich_all1$pvalue <- NULL

res_enrich_liv1 <- dplyr::select(restrt_liv, gene, pvalue)
res_enrich_liv1$liv <- as.integer(res_enrich_liv1$pvalue)+ 1
res_enrich_liv1$pvalue <- NULL

res_enrich_lu1 <- dplyr::select(restrt_lu, gene, pvalue)
res_enrich_lu1$lu <- as.integer(res_enrich_lu1$pvalue)+ 1
res_enrich_lu1$pvalue <- NULL

res_enrich_gi1 <- dplyr::select(restrt_gi, gene, pvalue)
res_enrich_gi1$gi <- as.integer(res_enrich_gi1$pvalue)+ 1
res_enrich_gi1$pvalue <- NULL

df_list <- list(res_enrich_all1, res_enrich_liv1, res_enrich_lu1, res_enrich_gi1)

# merge all data frames and move the common column to first position and keep all other columns
newdf <- df_list %>% purrr::reduce(full_join, by='gene') %>% 
dplyr::select(gene, everything())

newdf[is.na(newdf)] = 0
newdf[newdf > 0] <- 1

library(UpSetR)
upset(newdf, sets = c("all", "liv", "lu", "gi"), mb.ratio = c(0.55, 0.45), order.by = "freq")
```